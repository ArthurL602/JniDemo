#include <jni.h>
#include <string.h>
#include "android_log.h"

/**
 * 参数的传递本质就是一个赋值的过程，赋值就是对内存进行拷贝，是指将一块内存上的数据复制到另一块内存上
 * 在C++ 中 数组、结构体、类是聚合类型，频繁进行内存拷贝会消耗很多时间；
 * C/C++ 禁止在函数调用时直接传递数组内容，而是强制传递数组指指针
 * C++ 中的引用：
 * 引用可以看作时数据的一个别名，通过这个别名和原来的名字都能够找到这份数据
 * 引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，类似于常量
 * 引用的本质就是对指针的封装
 * 引用和指针的区别：
 * 1. 引用必须在定义的时候初始化，而且要从一而终，不能指向其他数据，而指针没有这个限制
 * 2. 可以有const 指针，但是没有 const 引用,不能定义为 int & const a = b 的形式，但是可以定义为：int const & a= b
 * 3. 指针可以有多级，但是引用不行；
 * 4. 指针使用 ++ 表示指向下一份数据，而引用表示它所指代的数据本身加 1；
 *
 * C++引用不能绑定到临时数据：
 * 指针变量指向的是内存中的数据或代码，如果数据不是存放在内存中，那么无法使用 & 获取它们的地址（如：表达式的结果，函数的返回值等有可能存放在内存，也有可能
 * 存放在寄存器中）
 *
 * 什么样的临时数据会放到寄存器中？
 * 基本数据类型的临时数据通常会放到寄存器中；而对象、结构体变量这些类型的临时数据通常存放在内存中。
 *
 * 常量表达式虽然在内存中，但是没办法寻址。也不能使用 & 来获取它们的地址
 *
 * 普通引用不能绑定临时数据，但是使用const 关键字后，就能绑定临时数据，因为编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入
 * 临时变量中，然后再引用绑定到该临时变量。
 *
 * 引用类型的函数形参请尽可能的使用 const
 *
 */

extern "C"
JNIEXPORT void JNICALL
Java_com_ljb_jnidemo_utils_JniUtils_callCPlusPlusRefrence(JNIEnv *env, jobject thiz) {
}